"""
What does the expression `ex` represent? Can it be documented? :symbol is used
to resolve functions and modules in the calling module's context -- after `@doc`
has returned.
"""
object_category(ex) =
    ismethod(ex) ? :method    :
    ismacro(ex)  ? :macro     :
    istype(ex)   ? :type      :
    isalias(ex)  ? :typealias :
    isglobal(ex) ? :global    :
    issymbol(ex) ? :symbol    :
    istuple(ex)  ? :tuple     :
    isvcat(ex)   ? :vcat      :
    isvect(ex)   ? :vect      :
    error("@doc: cannot document object:\n$(ex)")

ismethod(ex) = isexpr(ex, [:function, :(=)]) && isexpr(ex.args[1], :call)
isglobal(ex) = isexpr(ex, [:global, :const, :(=)]) && !isexpr(ex.args[1], :call)
istype(ex)   = isexpr(ex, [:type, :abstract])
isalias(ex)  = isexpr(ex, :typealias)
ismacro(ex)  = isexpr(ex, :macro)
ismodule(ex) = isexpr(ex, :module)
isfor(ex)    = isexpr(ex, :for)
iscurly(ex)  = isexpr(ex, :curly)
istuple(ex)  = isexpr(ex, :tuple)
isvcat(ex)   = isexpr(ex, :vcat)
isvect(ex)    = isexpr(ex, :vect)
iswhile(ex)  = isexpr(ex, :while)
isloop(ex)   = isexpr(ex, [:for, :while])

isconcretetype(ex) = isexpr(ex, [:type, :immutable])

"Handle modules and functions as symbols at later stage."
issymbol(s::Symbol) = true
issymbol(ex) = false

"What does the symbol ``symb`` represent in the current module ``curmod``?"
function lateguess(curmod, symb)
    isdefined(curmod, symb) || error("@doc: undefined object: $(symb)")
    guess(getfield(curmod, symb))
end
guess(f::Function) = :function
guess(m::Module)   = :module
guess(unknown)     = error("@doc: cannot document a $(unknown)")

"Extract the symbol identifying an expression."
function name(ex::Expr)
    n = isa(ex.args[1], Bool)    ? ex.args[2] :           # types
        isexpr(ex.args[1], :(.)) ? ex.args[1].args[end] : # qualified names
        ex.args[1]
    name(n)
end
name(q::QuoteNode) = q.value
name(s::Symbol) = s

"Returns as a tuple the module name as well as the full method name."
function qualifiedname(ex::Expr)
    if isexpr(ex.args[1], :(.))
        (ex.args[1].args[1], ex.args[1])
    else
        qualifiedname(ex.args[1])
    end
end
qualifiedname(s::Symbol) = (:(current_module()), s)

"""
Split the expressions passed to `@doc` into data and object. The docstring and
metadata dict in the first tuple are the data, while the second returned value
is the actual piece of code being documented.
"""
function separate(expr)
    data, obj = expr.args
    (data,), obj
end
function separate(docs, expr)
    meta, obj = expr.args
    (docs, meta), obj
end

"""
Attaching metadata to the generic function rather than the specific method which
the ``@doc`` is applied to.
"""
function docstar(symb::Symbol, args...)
    (generic = symb == :(*);), generic ? args : (symb, args...)
end
docstar(args...) = (false, args)

"""
Returns the line number and filename of the documented object. This is based on
the ``LineNumberNode`` provided by ``->`` and is sometimes a few lines out.
"""
function findsource(obj)
    loc = obj.args[1].args
    (loc[1], string(loc[2]))
end

# Handle both kinds of config.
docstrings(; args...) = Dict{Symbol, Any}(args)
# TODO: deprecated.
function docstrings(d::Dict)
    Base.warn_once("Dict-based `@docstring` config is deprecated. Use keywords instead.")
    d
end

"""
Module documentation initialiser. Optional.

The macro creates the required `Documentation` object used to store a module's
docstrings. When no `@docstrings` in provided the first `@doc` usage will
automatically generate the required `Documentation` object without additional
metadata.

**Example:**

```julia
using Docile
@docstrings(manual = ["../doc/manual.md"])

```

Available keywords are `manual` and `format`. Others will become available in
the future.

`format` specifies the default format to use for all docstrings in a module.
`:md` is the default format.

`manual` is a vector of files that make up a module's manual section. The paths
must be specified relative to the source file where `@docstrings` is called
from.

The manual sections may be viewed using the `manual` function from
[Lexicon.jl](https://github.com/MichaelHatherly/Lexicon.jl) and are included in
the HTML documentation generated by *Lexicon*.
"""
macro docstrings(args...)
    :(const $(esc(METADATA)) = Metadata(current_module(), @__FILE__, docstrings($(args...))))
end

"""
Document objects in source code such as *functions*, *methods*, *macros*,
*types*, *globals*, and *modules*.

Takes a string as documentation or a `meta` object containing a docstring and/or
additional metadata. See `meta` for further details.

**Examples:**

```julia
@docstrings

@doc "A single line method docstring with no metadata." ->
f(x) = x

@doc meta("A single line macro docstring with some arbitrary metadata.",
          author = "Author Name") ->
macro g(x)
    x
end

@doc \"\"\"
A longer docstring for a type in a triple quoted string with no metadata.
\"\"\" ->
type F
    # ...
end

@doc meta(\"\"\"
A triple quoted docstring for a global with metadata.
\"\"\", status = (:deprecated, v"0.1.0")) ->
const ABC = 1

value = "interpolated"

@doc \"\"\"
Since docstrings are just normal strings values can be \$(value) into
them from the surrounding scope or calculated, \$(rand()), when the
module is loaded.
\"\"\" ->
immutable G
    # ...
end
```

### Documenting Functions and Methods

Adding documentation to a `Function` rather than a specific `Method` can be
achieved in two ways.

**Case 1**

Documentation may be added *after* the first definition of a method. In the
following example documentation is added to the method `f(x)` and then to the
generic function `f`.

```julia
@doc "Method specific documentation." ->
function f(x)
    x
end

@doc "Documentation for generic function `f`." -> f
```

*Note:* The `f` may be written directly after the `->` or on the subsequent
line.

**Case 2**

There may only be generic documentation for a function and none that is
method-specific. In this case the generic documentation may be written directly
above one of the methods by using `@doc*`. The documentation will then be
associated with the `Function` object rather than that particular `Method`.

```julia
@doc* "Generic documentation for this function." ->
function f(x)
    x
end
```

### Documentation Formatting and Interpolation

Currently the only supported format for docstrings is markdown as provided by
the Markdown.jl package.

By default all docstrings will be stored in `Docs{:md}` types. This default may
be changed (once other formats become available) using the `@docstring` macro
metadata (see [@docstrings](#@docstrings) for details).

Since `\$` and `\\` are not interpreted literally in strings, string macros
`@md_str` and `@md_mstr` are provided to make it easier to enter LaTeX equations
in docstrings. The [@md_str](#@md_str) entry provides details.
"""
macro doc(args...); doc(args...); end

function doc(args...)
    isexpr(last(args), :(->)) || error("@doc: use `->` to separate docs/object:\n$(args)")

    # Check for `@doc*` syntax and separate the args out.
    generic, args = docstar(args...)

    # Separate out the documentation and metadata (data) from the object (obj).
    data, obj = separate(args...)

    # Find the category and name of an object. Build corresponding quoted expressions
    # for use in the `quote` returned. Macros names are prefixed by `@` here.
    c, n   = object_category(obj.args[2]), name(obj.args[2])
    qc, qn = Expr(:quote, c), Expr(:quote, c == :macro ? obj.args[end].args[1] : n)

    (generic && c != :method) && error("@doc: generic docstrings only allowed for methods.")

    # Capture the line and file.
    source = findsource(obj)

    autodocs = :(isdefined($(Expr(:quote, METADATA))) || @docstrings)

    # Prebuilt expressions on single lines to avoid packing extra lines into destination module.
    if generic

        qmod, n = qualifiedname(obj.args[2])

        esc(:($autodocs; $obj; Docile.setmeta!(current_module(), $n, :function, $source, $(data...)); $n))

    elseif c == :method

        qmod, n = qualifiedname(obj.args[2])

        before = gensym()
        oset = :($before = isdefined($qmod, $qn) ? Set(methods($n)) : Set{Method}())
        nset = :(setdiff(Set(methods($n)), $before))

        esc(:($autodocs; $oset; $obj; Docile.setmeta!(current_module(), $nset, :method, $source, $(data...)); $n))

    else

        # Category of entry.
        cat = c == :symbol ? :(Docile.lateguess(current_module(), $qn)) : :($qc)

        # Macros, types, globals, modules, functions (not attached to a method)
        var = c in (:type, :symbol) ? :($n) : :($qn)
        esc(:($autodocs; $obj; Docile.setmeta!(current_module(), $var, $cat, $source, $(data...))))

    end
end
